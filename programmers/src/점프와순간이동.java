public class 점프와순간이동 {

  public static void main(String[] args) {

    System.out.println(solution(5));
    System.out.println(solution(6));
    System.out.println(solution(5000));
  }

  static int solution(int n) {
    int ans = 0;

    /*
    이동할 수 있는 경우는 2가지
    1. k 만큼 앞으로 점프 -> k 만큼 배터리 사용
    2. 현재까지 온 거리 * 2 의 지점으로 순간이동 -> 배터리 소모 X

    n 지점으로 이동할 때, 사용될 배터리의 최솟값을 찾는 문제이다.

    배터리를 최소로 사용하려면 순간이동을 최대로 사용하고 최소한의 경우에만 점프를 해야한다.

    따라서 n 값에서 2를 나눠가며, 과정에서 나오는 모든 나머지값(0 또는 1)을 ans 에 더해주었다.
    ==
    n / 2(순간이동 시작 지점) + n % 2(점프거리 0 또는 1) -> n(도착지점)
    ==
    n / 2(순간이동 시작 지점) 지점에서 순간이동(n/2(시작지점) * 2) + 점프(n % 2) = n(도착지점)

    이 과정을 첫번째 예시에 비유하면

    1.
    5 / 2 ==> 몫: 2, 나머지: 1
    에서는
    2(순간이동 시작 지점: 5/2) 지점에서 순간이동(2(시작지점) * 2) + 1(5 % 2)만큼 점프한다.

    2.
    2 / 2 ==> 몫: 1, 나머지: 0
    에서는
    1(순간이동 시작 지점: 2/2) 지점에서 순간이동(1(시작지점) * 2), 점프는 없다(2 % 2).

    3.
    1 / 2 ==> 몫: 0, 나머지: 1
    에서는
    0(순간이동 시작 지점: 1/2) 지점에서 순간이동은 없고(0(시작지점) * 2), 1(1 % 2)만큼 점프한다.


    결과적으로
    0 -(점프)-> 1 -(순간이동)-> 2 -(순간이동)-> 4 -(점프)-> 5
    로 2만큼 점프하므로 최소 배터리 소모는 2가 나오게된다.
     */

    while (n > 0) {
      ans += n % 2;
      n /= 2;
    }

    return ans;
  }
}
